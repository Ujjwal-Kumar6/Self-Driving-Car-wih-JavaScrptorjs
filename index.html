<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Driving Car - Neural Network AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1e3a8a 0%, #7c3aed 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            display: flex;
            gap: 20px;
            padding: 20px;
        }
        
        .canvas-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        canvas {
            background: #2d3748;
            border: 3px solid white;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        
        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            width: 280px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        h2 {
            color: #1e3a8a;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #7c3aed;
            padding-bottom: 8px;
        }
        
        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat {
            background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-label {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 4px;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #1e3a8a;
        }
        
        .control-section {
            margin-bottom: 20px;
        }
        
        .control-section h3 {
            font-size: 14px;
            color: #4b5563;
            margin-bottom: 10px;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.4);
        }
        
        .slider-control {
            margin: 15px 0;
        }
        
        .slider-control label {
            display: block;
            font-size: 12px;
            color: #4b5563;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .slider-control input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
        }
        
        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #7c3aed;
            cursor: pointer;
        }
        
        .slider-value {
            display: inline-block;
            float: right;
            font-weight: bold;
            color: #7c3aed;
        }
        
        .info-box {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            color: #78350f;
            line-height: 1.5;
        }
        
        .info-box strong {
            display: block;
            margin-bottom: 5px;
            color: #92400e;
        }
        
        .progress-bar {
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #7c3aed 0%, #3b82f6 100%);
            transition: width 0.3s;
        }
        
        .network-viz {
            background: #1e293b;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .network-viz canvas {
            border: none;
            background: transparent;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <canvas id="carCanvas" width="300" height="600"></canvas>
            <div class="network-viz">
                <canvas id="networkCanvas" width="300" height="200"></canvas>
            </div>
        </div>
        
        <div class="panel">
            <h2>üöó AI Training Dashboard</h2>
            
            <div class="stat-grid">
                <div class="stat">
                    <div class="stat-label">Generation</div>
                    <div class="stat-value" id="generation">1</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Best Score</div>
                    <div class="stat-value" id="bestScore">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Cars Alive</div>
                    <div class="stat-value" id="carsAlive">50</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Avg Speed</div>
                    <div class="stat-value" id="avgSpeed">0</div>
                </div>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%"></div>
            </div>
            
            <div class="control-section">
                <h3>üéÆ Controls</h3>
                <button class="btn-primary" onclick="startTraining()">‚ñ∂Ô∏è Start Training</button>
                <button class="btn-secondary" onclick="skipGeneration()">‚è≠Ô∏è Skip Generation</button>
                <button class="btn-secondary" onclick="saveBrain()">üíæ Save Best Brain</button>
                <button class="btn-secondary" onclick="loadBrain()">üìÇ Load Saved Brain</button>
            </div>
            
            <div class="control-section">
                <h3>‚öôÔ∏è Fine-Tuning</h3>
                
                <div class="slider-control">
                    <label>
                        Mutation Rate
                        <span class="slider-value" id="mutationValue">0.10</span>
                    </label>
                    <input type="range" id="mutationRate" min="0" max="0.5" step="0.01" value="0.10" 
                           oninput="updateMutationRate(this.value)">
                </div>
                
                <div class="slider-control">
                    <label>
                        Population Size
                        <span class="slider-value" id="popValue">50</span>
                    </label>
                    <input type="range" id="populationSize" min="20" max="200" step="10" value="50" 
                           oninput="updatePopulation(this.value)">
                </div>
                
                <div class="slider-control">
                    <label>
                        Elite Count
                        <span class="slider-value" id="eliteValue">3</span>
                    </label>
                    <input type="range" id="eliteCount" min="1" max="10" step="1" value="3" 
                           oninput="updateElite(this.value)">
                </div>
            </div>
            
            <div class="info-box">
                <strong>üéØ How It Works:</strong>
                Cars use 5 ray sensors to detect obstacles. A neural network (5‚Üí6‚Üí4) processes sensor data and outputs steering/speed decisions. Best performers pass their "genes" to the next generation through mutation and selection.
            </div>
        </div>
    </div>

    <script>
        // Configuration
        let config = {
            mutationRate: 0.10,
            populationSize: 50,
            eliteCount: 3,
            trainingActive: false
        };
        
        // Canvas setup
        const carCanvas = document.getElementById('carCanvas');
        const carCtx = carCanvas.getContext('2d');
        const networkCanvas = document.getElementById('networkCanvas');
        const networkCtx = networkCanvas.getContext('2d');
        
        // Neural Network
        class NeuralNetwork {
            constructor(neuronCounts) {
                this.levels = [];
                for (let i = 0; i < neuronCounts.length - 1; i++) {
                    this.levels.push(new Level(
                        neuronCounts[i],
                        neuronCounts[i + 1]
                    ));
                }
            }
            
            static feedForward(givenInputs, network) {
                let outputs = Level.feedForward(givenInputs, network.levels[0]);
                for (let i = 1; i < network.levels.length; i++) {
                    outputs = Level.feedForward(outputs, network.levels[i]);
                }
                return outputs;
            }
            
            static mutate(network, amount = 1) {
                network.levels.forEach(level => {
                    for (let i = 0; i < level.biases.length; i++) {
                        level.biases[i] = lerp(level.biases[i], Math.random() * 2 - 1, amount);
                    }
                    for (let i = 0; i < level.weights.length; i++) {
                        for (let j = 0; j < level.weights[i].length; j++) {
                            level.weights[i][j] = lerp(
                                level.weights[i][j],
                                Math.random() * 2 - 1,
                                amount
                            );
                        }
                    }
                });
            }
        }
        
        class Level {
            constructor(inputCount, outputCount) {
                this.inputs = new Array(inputCount);
                this.outputs = new Array(outputCount);
                this.biases = new Array(outputCount);
                this.weights = [];
                
                for (let i = 0; i < inputCount; i++) {
                    this.weights[i] = new Array(outputCount);
                }
                
                Level.randomize(this);
            }
            
            static randomize(level) {
                for (let i = 0; i < level.inputs.length; i++) {
                    for (let j = 0; j < level.outputs.length; j++) {
                        level.weights[i][j] = Math.random() * 2 - 1;
                    }
                }
                
                for (let i = 0; i < level.biases.length; i++) {
                    level.biases[i] = Math.random() * 2 - 1;
                }
            }
            
            static feedForward(givenInputs, level) {
                for (let i = 0; i < level.inputs.length; i++) {
                    level.inputs[i] = givenInputs[i];
                }
                
                for (let i = 0; i < level.outputs.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < level.inputs.length; j++) {
                        sum += level.inputs[j] * level.weights[j][i];
                    }
                    level.outputs[i] = sum > level.biases[i] ? 1 : 0;
                }
                
                return level.outputs;
            }
        }
        
        // Sensor
        class Sensor {
            constructor(car) {
                this.car = car;
                this.rayCount = 5;
                this.rayLength = 150;
                this.raySpread = Math.PI / 2;
                this.rays = [];
                this.readings = [];
            }
            
            update(roadBorders, traffic) {
                this.castRays();
                this.readings = [];
                for (let i = 0; i < this.rays.length; i++) {
                    this.readings.push(
                        this.getReading(this.rays[i], roadBorders, traffic)
                    );
                }
            }
            
            getReading(ray, roadBorders, traffic) {
                let touches = [];
                
                for (let i = 0; i < roadBorders.length; i++) {
                    const touch = getIntersection(
                        ray[0], ray[1],
                        roadBorders[i][0], roadBorders[i][1]
                    );
                    if (touch) touches.push(touch);
                }
                
                for (let i = 0; i < traffic.length; i++) {
                    const poly = traffic[i].polygon;
                    for (let j = 0; j < poly.length; j++) {
                        const touch = getIntersection(
                            ray[0], ray[1],
                            poly[j], poly[(j + 1) % poly.length]
                        );
                        if (touch) touches.push(touch);
                    }
                }
                
                if (touches.length == 0) return null;
                
                const offsets = touches.map(e => e.offset);
                const minOffset = Math.min(...offsets);
                return touches.find(e => e.offset == minOffset);
            }
            
            castRays() {
                this.rays = [];
                for (let i = 0; i < this.rayCount; i++) {
                    const rayAngle = lerp(
                        this.raySpread / 2,
                        -this.raySpread / 2,
                        this.rayCount == 1 ? 0.5 : i / (this.rayCount - 1)
                    ) + this.car.angle;
                    
                    const start = { x: this.car.x, y: this.car.y };
                    const end = {
                        x: this.car.x - Math.sin(rayAngle) * this.rayLength,
                        y: this.car.y - Math.cos(rayAngle) * this.rayLength
                    };
                    this.rays.push([start, end]);
                }
            }
            
            draw(ctx) {
                for (let i = 0; i < this.rayCount; i++) {
                    let end = this.rays[i][1];
                    if (this.readings[i]) {
                        end = this.readings[i];
                    }
                    
                    ctx.beginPath();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'yellow';
                    ctx.moveTo(this.rays[i][0].x, this.rays[i][0].y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'black';
                    ctx.moveTo(this.rays[i][1].x, this.rays[i][1].y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                }
            }
        }
        
        // Car
        class Car {
            constructor(x, y, width, height, controlType, maxSpeed = 3) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                
                this.speed = 0;
                this.acceleration = 0.2;
                this.maxSpeed = maxSpeed;
                this.friction = 0.05;
                this.angle = 0;
                
                this.damaged = false;
                this.fitness = 0;
                
                this.useBrain = controlType == "AI";
                
                if (controlType != "DUMMY") {
                    this.sensor = new Sensor(this);
                    this.brain = new NeuralNetwork([this.sensor.rayCount, 6, 4]);
                }
                this.controls = new Controls(controlType);
                
                this.polygon = this.createPolygon();
            }
            
            update(roadBorders, traffic) {
                if (!this.damaged) {
                    this.move();
                    this.polygon = this.createPolygon();
                    this.damaged = this.assessDamage(roadBorders, traffic);
                    this.fitness++;
                }
                if (this.sensor) {
                    this.sensor.update(roadBorders, traffic);
                    const offsets = this.sensor.readings.map(
                        s => s == null ? 0 : 1 - s.offset
                    );
                    const outputs = NeuralNetwork.feedForward(offsets, this.brain);
                    
                    if (this.useBrain) {
                        this.controls.forward = outputs[0];
                        this.controls.left = outputs[1];
                        this.controls.right = outputs[2];
                        this.controls.reverse = outputs[3];
                    }
                }
            }
            
            assessDamage(roadBorders, traffic) {
                for (let i = 0; i < roadBorders.length; i++) {
                    if (polysIntersect(this.polygon, roadBorders[i])) {
                        return true;
                    }
                }
                for (let i = 0; i < traffic.length; i++) {
                    if (polysIntersect(this.polygon, traffic[i].polygon)) {
                        return true;
                    }
                }
                return false;
            }
            
            createPolygon() {
                const points = [];
                const rad = Math.hypot(this.width, this.height) / 2;
                const alpha = Math.atan2(this.width, this.height);
                points.push({
                    x: this.x - Math.sin(this.angle - alpha) * rad,
                    y: this.y - Math.cos(this.angle - alpha) * rad
                });
                points.push({
                    x: this.x - Math.sin(this.angle + alpha) * rad,
                    y: this.y - Math.cos(this.angle + alpha) * rad
                });
                points.push({
                    x: this.x - Math.sin(Math.PI + this.angle - alpha) * rad,
                    y: this.y - Math.cos(Math.PI + this.angle - alpha) * rad
                });
                points.push({
                    x: this.x - Math.sin(Math.PI + this.angle + alpha) * rad,
                    y: this.y - Math.cos(Math.PI + this.angle + alpha) * rad
                });
                return points;
            }
            
            move() {
                if (this.controls.forward) {
                    this.speed += this.acceleration;
                }
                if (this.controls.reverse) {
                    this.speed -= this.acceleration;
                }
                
                if (this.speed > this.maxSpeed) {
                    this.speed = this.maxSpeed;
                }
                if (this.speed < -this.maxSpeed / 2) {
                    this.speed = -this.maxSpeed / 2;
                }
                
                if (this.speed > 0) {
                    this.speed -= this.friction;
                }
                if (this.speed < 0) {
                    this.speed += this.friction;
                }
                if (Math.abs(this.speed) < this.friction) {
                    this.speed = 0;
                }
                
                if (this.speed != 0) {
                    const flip = this.speed > 0 ? 1 : -1;
                    if (this.controls.left) {
                        this.angle += 0.03 * flip;
                    }
                    if (this.controls.right) {
                        this.angle -= 0.03 * flip;
                    }
                }
                
                this.x -= Math.sin(this.angle) * this.speed;
                this.y -= Math.cos(this.angle) * this.speed;
            }
            
            draw(ctx, color, drawSensor = false) {
                if (this.damaged) {
                    ctx.fillStyle = "gray";
                } else {
                    ctx.fillStyle = color;
                }
                ctx.beginPath();
                ctx.moveTo(this.polygon[0].x, this.polygon[0].y);
                for (let i = 1; i < this.polygon.length; i++) {
                    ctx.lineTo(this.polygon[i].x, this.polygon[i].y);
                }
                ctx.fill();
                
                if (this.sensor && drawSensor) {
                    this.sensor.draw(ctx);
                }
            }
        }
        
        // Controls
        class Controls {
            constructor(type) {
                this.forward = false;
                this.left = false;
                this.right = false;
                this.reverse = false;
                
                switch (type) {
                    case "KEYS":
                        this.addKeyboardListeners();
                        break;
                    case "DUMMY":
                        this.forward = true;
                        break;
                }
            }
            
            addKeyboardListeners() {
                document.onkeydown = (event) => {
                    switch (event.key) {
                        case "ArrowLeft":
                            this.left = true;
                            break;
                        case "ArrowRight":
                            this.right = true;
                            break;
                        case "ArrowUp":
                            this.forward = true;
                            break;
                        case "ArrowDown":
                            this.reverse = true;
                            break;
                    }
                }
                document.onkeyup = (event) => {
                    switch (event.key) {
                        case "ArrowLeft":
                            this.left = false;
                            break;
                        case "ArrowRight":
                            this.right = false;
                            break;
                        case "ArrowUp":
                            this.forward = false;
                            break;
                        case "ArrowDown":
                            this.reverse = false;
                            break;
                    }
                }
            }
        }
        
        // Road
        class Road {
            constructor(x, width, laneCount = 3) {
                this.x = x;
                this.width = width;
                this.laneCount = laneCount;
                
                this.left = x - width / 2;
                this.right = x + width / 2;
                
                const infinity = 1000000;
                this.top = -infinity;
                this.bottom = infinity;
                
                const topLeft = { x: this.left, y: this.top };
                const topRight = { x: this.right, y: this.top };
                const bottomLeft = { x: this.left, y: this.bottom };
                const bottomRight = { x: this.right, y: this.bottom };
                this.borders = [
                    [topLeft, bottomLeft],
                    [topRight, bottomRight]
                ];
            }
            
            getLaneCenter(laneIndex) {
                const laneWidth = this.width / this.laneCount;
                return this.left + laneWidth / 2 + Math.min(laneIndex, this.laneCount - 1) * laneWidth;
            }
            
            draw(ctx) {
                ctx.lineWidth = 5;
                ctx.strokeStyle = "white";
                
                for (let i = 1; i <= this.laneCount - 1; i++) {
                    const x = lerp(this.left, this.right, i / this.laneCount);
                    
                    ctx.setLineDash([20, 20]);
                    ctx.beginPath();
                    ctx.moveTo(x, this.top);
                    ctx.lineTo(x, this.bottom);
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                this.borders.forEach(border => {
                    ctx.beginPath();
                    ctx.moveTo(border[0].x, border[0].y);
                    ctx.lineTo(border[1].x, border[1].y);
                    ctx.stroke();
                });
            }
        }
        
        // Visualizer for Neural Network
        class Visualizer {
            static drawNetwork(ctx, network) {
                const margin = 50;
                const left = margin;
                const top = margin;
                const width = ctx.canvas.width - margin * 2;
                const height = ctx.canvas.height - margin * 2;
                
                const levelHeight = height / network.levels.length;
                
                for (let i = network.levels.length - 1; i >= 0; i--) {
                    const levelTop = top +
                        lerp(
                            height - levelHeight,
                            0,
                            network.levels.length == 1
                                ? 0.5
                                : i / (network.levels.length - 1)
                        );
                    
                    ctx.setLineDash([7, 3]);
                    Visualizer.drawLevel(ctx, network.levels[i],
                        left, levelTop,
                        width, levelHeight,
                        i == network.levels.length - 1
                            ? ['‚Üë', '‚Üê', '‚Üí', '‚Üì']
                            : []
                    );
                }
            }
            
            static drawLevel(ctx, level, left, top, width, height, outputLabels) {
                const right = left + width;
                const bottom = top + height;
                
                const { inputs, outputs, weights, biases } = level;
                
                for (let i = 0; i < inputs.length; i++) {
                    for (let j = 0; j < outputs.length; j++) {
                        ctx.beginPath();
                        ctx.moveTo(
                            Visualizer.getNodeX(inputs, i, left, right),
                            bottom
                        );
                        ctx.lineTo(
                            Visualizer.getNodeX(outputs, j, left, right),
                            top
                        );
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = getRGBA(weights[i][j]);
                        ctx.stroke();
                    }
                }
                
                const nodeRadius = 18;
                for (let i = 0; i < inputs.length; i++) {
                    const x = Visualizer.getNodeX(inputs, i, left, right);
                    ctx.beginPath();
                    ctx.arc(x, bottom, nodeRadius, 0, Math.PI * 2);
                    ctx.fillStyle = "black";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x, bottom, nodeRadius * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = getRGBA(inputs[i]);
                    ctx.fill();
                }
                
                for (let i = 0; i < outputs.length; i++) {
                    const x = Visualizer.getNodeX(outputs, i, left, right);
                    ctx.beginPath();
                    ctx.arc(x, top, nodeRadius, 0, Math.PI * 2);
                    ctx.fillStyle = "black";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x, top, nodeRadius * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = getRGBA(outputs[i]);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.lineWidth = 2;
                    ctx.arc(x, top, nodeRadius * 0.8, 0, Math.PI * 2);
                    ctx.strokeStyle = getRGBA(biases[i]);
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    if (outputLabels[i]) {
                        ctx.beginPath();
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillStyle = "white";
                        ctx.strokeStyle = "white";
                        ctx.font = (nodeRadius * 1.5) + "px Arial";
                        ctx.fillText(outputLabels[i], x, top + nodeRadius * 0.1);
                        ctx.lineWidth = 0.5;
                        ctx.strokeText(outputLabels[i], x, top + nodeRadius * 0.1);
                    }
                }
            }
            
            static getNodeX(nodes, index, left, right) {
                return lerp(
                    left,
                    right,
                    nodes.length == 1
                        ? 0.5
                        : index / (nodes.length - 1)
                );
            }
        }
        
        // Utility functions
        function lerp(A, B, t) {
            return A + (B - A) * t;
        }
        
        function getIntersection(A, B, C, D) {
            const tTop = (D.x - C.x) * (A.y - C.y) - (D.y - C.y) * (A.x - C.x);
            const uTop = (C.y - A.y) * (A.x - B.x) - (C.x - A.x) * (A.y - B.y);
            const bottom = (D.y - C.y) * (B.x - A.x) - (D.x - C.x) * (B.y - A.y);
            
            if (bottom != 0) {
                const t = tTop / bottom;
                const u = uTop / bottom;
                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                    return {
                        x: lerp(A.x, B.x, t),
                        y: lerp(A.y, B.y, t),
                        offset: t
                    }
                }
            }
            
            return null;
        }
        
        function polysIntersect(poly1, poly2) {
            for (let i = 0; i < poly1.length; i++) {
                for (let j = 0; j < poly2.length; j++) {
                    const touch = getIntersection(
                        poly1[i],
                        poly1[(i + 1) % poly1.length],
                        poly2[j],
                        poly2[(j + 1) % poly2.length]
                    );
                    if (touch) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function getRGBA(value) {
            const alpha = Math.abs(value);
            const R = value < 0 ? 0 : 255;
            const G = R;
            const B = value > 0 ? 0 : 255;
            return "rgba(" + R + "," + G + "," + B + "," + alpha + ")";
        }
        
        // Main simulation
        const road = new Road(carCanvas.width / 2, carCanvas.width * 0.9);
        let cars = [];
        let traffic = [];
        let bestCar;
        let generation = 1;
        
        function generateCars(N) {
            cars = [];
            for (let i = 0; i < N; i++) {
                cars.push(new Car(road.getLaneCenter(1), 100, 30, 50, "AI"));
            }
        }
        
        function generateTraffic() {
            traffic = [
                new Car(road.getLaneCenter(1), -100, 30, 50, "DUMMY", 2),
                new Car(road.getLaneCenter(0), -300, 30, 50, "DUMMY", 2),
                new Car(road.getLaneCenter(2), -300, 30, 50, "DUMMY", 2),
                new Car(road.getLaneCenter(0), -500, 30, 50, "DUMMY", 2),
                new Car(road.getLaneCenter(1), -500, 30, 50, "DUMMY", 2),
                new Car(road.getLaneCenter(1), -700, 30, 50, "DUMMY", 2),
                new Car(road.getLaneCenter(2), -900, 30, 50, "DUMMY", 2),
            ];
        }
        
        function startTraining() {
            config.trainingActive = true;
            generateCars(config.populationSize);
            generateTraffic();
            if (localStorage.getItem("bestBrain")) {
                for (let i = 0; i < cars.length; i++) {
                    cars[i].brain = JSON.parse(localStorage.getItem("bestBrain"));
                    if (i != 0) {
                        NeuralNetwork.mutate(cars[i].brain, config.mutationRate);
                    }
                }
            }
            bestCar = cars[0];
        }
        
        function skipGeneration() {
            if (cars.length == 0) return;
            save();
            generation++;
            generateCars(config.populationSize);
            
            // Elite selection
            const elite = cars.slice(0, config.eliteCount);
            
            for (let i = 0; i < cars.length; i++) {
                cars[i].brain = JSON.parse(localStorage.getItem("bestBrain"));
                if (i < config.eliteCount) {
                    // Keep elite with minimal mutation
                    NeuralNetwork.mutate(cars[i].brain, config.mutationRate * 0.1);
                } else {
                    // Mutate others normally
                    NeuralNetwork.mutate(cars[i].brain, config.mutationRate);
                }
            }
            generateTraffic();
            bestCar = cars[0];
        }
        
        function save() {
            if (!bestCar) return;
            localStorage.setItem("bestBrain", JSON.stringify(bestCar.brain));
        }
        
        function saveBrain() {
            save();
            alert("Brain saved! ‚úì");
        }
        
        function loadBrain() {
            if (localStorage.getItem("bestBrain")) {
                for (let i = 0; i < cars.length; i++) {
                    cars[i].brain = JSON.parse(localStorage.getItem("bestBrain"));
                    if (i != 0) {
                        NeuralNetwork.mutate(cars[i].brain, config.mutationRate);
                    }
                }
                alert("Brain loaded! ‚úì");
            }
        }
        
        function updateMutationRate(value) {
            config.mutationRate = parseFloat(value);
            document.getElementById('mutationValue').textContent = value;
        }
        
        function updatePopulation(value) {
            config.populationSize = parseInt(value);
            document.getElementById('popValue').textContent = value;
        }
        
        function updateElite(value) {
            config.eliteCount = parseInt(value);
            document.getElementById('eliteValue').textContent = value;
        }
        
        function updateStats() {
            if (cars.length == 0) return;
            
            const aliveCount = cars.filter(c => !c.damaged).length;
            const avgSpeed = cars.reduce((sum, c) => sum + Math.abs(c.speed), 0) / cars.length;
            const progress = (aliveCount / cars.length) * 100;
            
            document.getElementById('generation').textContent = generation;
            document.getElementById('bestScore').textContent = Math.floor(-bestCar.y);
            document.getElementById('carsAlive').textContent = aliveCount;
            document.getElementById('avgSpeed').textContent = avgSpeed.toFixed(1);
            document.getElementById('progressBar').style.width = progress + '%';
            
            // Auto-advance generation when all cars are dead
            if (aliveCount == 0 && config.trainingActive) {
                setTimeout(skipGeneration, 500);
            }
        }
        
        function animate(time) {
            for (let i = 0; i < traffic.length; i++) {
                traffic[i].update(road.borders, []);
            }
            for (let i = 0; i < cars.length; i++) {
                cars[i].update(road.borders, traffic);
            }
            
            if (cars.length > 0) {
                bestCar = cars.find(
                    c => c.y == Math.min(...cars.map(c => c.y))
                );
            }
            
            carCanvas.height = window.innerHeight;
            networkCanvas.height = 200;
            
            carCtx.save();
            carCtx.translate(0, -bestCar.y + carCanvas.height * 0.7);
            
            road.draw(carCtx);
            for (let i = 0; i < traffic.length; i++) {
                traffic[i].draw(carCtx, "red");
            }
            carCtx.globalAlpha = 0.2;
            for (let i = 0; i < cars.length; i++) {
                cars[i].draw(carCtx, "blue");
            }
            carCtx.globalAlpha = 1;
            bestCar.draw(carCtx, "blue", true);
            
            carCtx.restore();
            
            networkCtx.lineDashOffset = -time / 50;
            Visualizer.drawNetwork(networkCtx, bestCar.brain);
            
            updateStats();
            requestAnimationFrame(animate);
        }
        
        // Initialize
        generateCars(config.populationSize);
        generateTraffic();
        bestCar = cars[0];
        animate(0);
    </script>
</body>
</html>
